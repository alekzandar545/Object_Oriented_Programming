<h1>Въведение в CI/CD. Какво е git и как се използва? Как да пишем unit test-ове?</h1>

<h3>1. Какво е git?</h3>

Терминологията на английски е "distributed version control system". С по-прости думи е система, с която може да се работи от много различни места и позволява добър контрол на версиите на даден софтуер.

<h3>Как да си го инсталираме?</h3>

Отивайки на [download](https://git-scm.com/downloads) страницата на официалният сайт, можем да свалим версията, която отговаря на нашата операционна система.

След като инсталираме програмата, трябва да можем, в който и да е терминал, да напишем `git --version` и да ни изпечата версията на git, която сме инсталирали. Ако обаче ни казва, че не разпознава git като команда, трябва да го добавим в системният път:

Стъпките описани работят за Windows, за Linux и Mac трябва да се мине през подобен процес.

1. Отваряме търсачката
2. Търсим `edit environment variables for your account`
3. Натискаме върху `PATH` в `System variables` секцията и след това `Edit`
4. Добавяме нов път, като натиснем `New`
5. Поставяме пътят на нашата инсталация на git и добавяме *'/cmd'* на края
6. Готови сме за работа!

Сега нека настройм нашият git, за да работи с активният ни акаунт. За целта трябва да изпълним тези команди:

`git config -global user.name "[name]"`
`git config -global user.email "[email]"`

<h3>Как се работи с git?</h3>

<h5>Пример за работно дърво в git:</h5>

![](https://lh3.googleusercontent.com/70jaEZnESXQ6SssU5uI4yO62JBz6xq2sNrrz8bW_ap2CuWUaQlbKs3j6NyRJnvcvYwAugkW8WzNJX21dZ2SMd9O_1TTpKZT-FsBkYSPy4rUSpJSo2C-WPTaLc2jQ8ancyj1TetXQ)

<h5>Как се постига?</h5>

Git работи на база commit-и. Това е главната промяна, която движи процеса. Всеки един клон на графиката по-горе има собствени commit-и. Като ние можем да разклоняваме и сливаме такива клони и техните commit-и.

<h3>Важни команди, които биха ни помогнали:</h3>

1. git config - с тази команда можем да правим промени по конфигурацията на нашия git
2. git init - инициализира repository
3. git status - показва статусът на текъщият branch.
4. git add [file1 fil2 ... fileN] - добавя конкретни файлове, в които има направена промяна.
5. git add . - добавя всички файлове, в които има направена промяна.
6. git commit -m "Commit message" - commit-ва добавените промени от add.
7. git push - публикува commit-ите в remote дървото.
8. git pull - изтегля промените от remote дървото.
9. git branch - позволява управление на branch-овете
10. git fetch - update-ва локалното дърво да вижда промените по remote дървото.
11. git checkout [branch_name] - сменя активният branch, върху който работим.
12. git clone [link/to/repo] - прави локално копие на git repository.
13. git log [--oneline] - дава информация, за commit-ите на дървото, като --oneline опцията ги съкращава на един ред всеки.
14. git reset --hard \<commit-hash> - връща всичко до commit-а, който сме му казали.
15. git merge - използва се, за да сливаме branch-ове

**!!!Важно!!!**
Commit прави само локална промяна в дървото. Push и pull от своя страна синхронизират remote с local repository-тата.

**[Тук](https://dzone.com/articles/top-20-git-commands-with-examples)** можете да намерите и добри примери, как да използвате тези и още команди.

<h3>Как да работим с git от VS Code</h3>

За работа с git използваме **Source Control** менюто. То ще изглежда подобно на това:
![](https://i.ibb.co/Y77xbvw/image.png)

<h3>.gitignore</h3>

.gitgnore е важен компонент от нашите repository-та, защото този файл ни позволява да специфицираме видове файлове или директории, които не искаме да замЪрсяват нашето repository.

<h5>Пример:</h5>

Имаме проект писан главно на C++. От него генерираме много object файлове, които не са нужни на другите хора, които също работят по проекта. Това е така, защото ако те променят нещо ще искат да компилират кода наново така или иначе. Така че такъв вид файлове са излишни за споделяне в главното репозитори.

Този .gitignore, може да бъде направен на ръка или генериран автоматично.

<h3>Secure Shell Protocol(SSH)</h3>

Git и платформите, които го използват, като Github и Gitlab, работят със secure протоколи. Два от тези са HTTPS и SSH. За да не навлизаме в подробности SSH протоколът е по-добър в енкриптирането и защитата на данните, и също така не трябва да пишете всеки път username и password за authentication.

Ето **[тук](https://www.theserverside.com/blog/Coffee-Talk-Java-News-Stories-and-Opinions/GitHub-SSH-Key-Setup-Config-Ubuntu-Linux)** можете да намерите добре описан guide, за това как да си настроите SSH.

<h3>2. Какво е unit testing?</h3>

<h3>Дефиниция</h3>

Тестването на индивидуални софтуерни компоненти (units).

<h3>Какво представлява unit?</h3>

Unit е най-малката частица код, която може да се test-ва (или си заслужава да се тества).
Обикновено това може да е цял модул, но в повечето случаи е функция или метод.
Има 1 или няколко входа и **един** изход.

*Някои от по-известните framework-ове.*

|Language  |Test framework  |
|----------|----------------|
|C++       |CppUnit, doctest|
|C#        |NUnit, csUnit   |
|Java      |JUnit, Jtest    |
|JavaScript|JSUnit, QUnit   |

<h3>Какъв подход се използва за писане на unit тестове?</h3>

- най-използвания подход е test \- function \- expected value
- идеята е, че тестваме точно определена функционалност
- В помощ на unit test-овете влизат method stubs, mock objects, fakes и test harnesses, 
като идеята е, че те ни позволяват да се фокусираме над това, което тестваме
- Целта на unit test-овете е да изолират всяка една част на програмата и да покажат, че е коректна.
- Unit test-овете намират проблеми от рано в development процесът

<h3>Code coverage</h3>

Code coverage е измеримост на това, колко линии/блокове от нашия код са изпълнени, докато автоматизираните тестове текат.

<h3>White vs Black box testing</h3>

- Black Box Testing е метод на тестване, при който вътрешната структура/дизайн/имплементация на тестваният блок не са известни на този, който ги тества.
- White Box Testing е метод на тестване, при който вътрешната структура/дизайн/имплементация на тестваният блок са известни на този, който ги тества.

<h3>Кой пише unit тестове?</h3>

- Обикновенно самите софтуерни разработчици пишат тестовете си.

<h3>Ползи от unit тестове</h3>

- Unit тестовете осигурява сигурност при промяна/поддръжка на кода ни.
- Кодът става преизползваем, защото кодът става на модули, които могат да бъдат тествани отделно.
- Усилията, които ще ни коства да оправим дефект, засечен по време на тестване, са по-малко отколкото да оправим дефект, засечен на по-високо ниво.
- Debug-ването е по-лесно.

<h3>Примери от живота</h3>

Нека приемем, че имаме програма, която се състои от два unit-а и единственият тест, който правим е системен тест. (Пропускаме unit и integration тестовете.)
По време на тестване намираме bug в програмата. Сега, как ще определим от къде идва той?

Имаме следните варианти:

- В unit 1 ли е проблемът?
- В unit 2 ли е проблемът?
- И в двата unit-а ли има проблеми?
- Проблемът в интерфейса между двата unit-а ли е?
- Проблемът в тестът или в тест case-ът е?

<h3>Doctest</h3>

- **[Тук](https://github.com/doctest/doctest)** можете да намерите doctest framework-а.

<h3>Test Driven Development (TDD)</h3>

**Test-driven development (TDD)** е процес за софтуерна разработка, който разчита на повторението на един много кратък цикъл на разработка:

- Първо програмистът пише тест, който не минава, обаче дефинира желано подобрение или нова функционалност.
- След това пише код, който да минава тестът.
- И накрая рефакторира новият код, за да е по-четим.

TDD методът за работа може да се опише, като повторение на следните стъпки (показани на снимката):

- Избираме, коя функционалност трябва да се имплементира.
- Добавяме тест(ове) за избраната функционалност.
- Компилираме, тестваме и гледаме дали има някакви грешки.
- Пишем код, който да работи.
- Рефакторираме написаният код.
- Повтаряме тестовете, оправяме кода ако има грешни тестове.
- Commit-ваме промените.
- Отиваме на следващата функционалност и повтаряме стъпките.

![](https://i.ibb.co/61tp58D/TDD.png)

<h3>Как да организираме тестовете си</h3>

Тестовите случаи често се комбинират в тестови пакети според някакъв критерии - подобна функционалналност, различни употреби за една и съща функция, общи приспособления и т.н.

Добър начин по който да ги организираме:

- Тестовият случай трябва да тестваме само едно нещо;
- Тестовият случай трябва да е кратък;
- Тестът трябва да работи бързо, за да може да се прави често;
- Всеки тест трябва да работи независимо от другите тестове. Грешен или неправилно направен тестови случай не трябва да пречи на другите тестове;
- Тестовете не трябва да разчитат на поредността, в която са пуснати;

- Ако се хвърли някаква грешка от някой от тестовете, програмата ще приключи и няма как да го спрем;
- Няма как да направим тест, който проверява конкретна подсистема на тестваният unit;

<h3>Mocking</h3>

В unit testing-а, mock objects могат да симулират поведението на комплекси обекти, които бихме използвали в реална ситуация. Ако имаме някое от следните характеристики за нашите обекти, mock обект би бил подходящ:

- Връща недетерминистични резултати (времето сега, температурата навън);
- Има ситации, които са трудни за пресъздаване (network error);
- Бавна инициализация (цяла база данни);
- Още не съществува или може да промени поведението си;
- Трябва да добави информация и методи, само заради тестоването (а не за своята задача);

<h3>3. Работа с външни библиотеки</h3>

<h3>a) Избираме библиотека, с която искаме да работим</h3>

- За целта на това упражнение, ще покажем библиотека за графични приложения. (SDL2)

<h3>б) Сваляме библиотеката</h3>

- Библиотеката можем да свалим от официалната им страница на [този](https://www.libsdl.org/) линк, или като клонираме [репозиторито](https://github.com/libsdl-org/SDL). Имайте предвид, че за да свалим SDL2, а не SDL3 трябва да сменим branch-а от main на SDL2!

- Ако сте го свалили от сайта, го разархивирайте в някоя папка.

- В папката на проекта трябва да имате следните 3 папки:

![](https://i.ibb.co/PzTwFz4/image.png)

<h3>в) Импортиране на библиотеката</h3>

- Сега можем да си направим специална папка, в която да добавяме нашите библиотеки. (/path/to/libraries/Libraries)

- В тази папка ще направим още една, която ще се казва SDL.

- Вътре ще прехвърлим include, lib папките и по желание bin папката (ще обясним, защо като стигнем до компилацията).

<h3>г) Оправяне на include path</h3>

Тази стъпка се прави, за да може нашият intellisense да разбира контекста на кода, който пишем вместо да подчертава всичко.

- Влизайки във VS Code можем да направим тестов проект като [този](/SDL%20Sample)

- Трябва да намерим нашият c_cpp_properties.json/settings.json файл и в includePath секцията да добавите пътя към include папката на библиотеката. Другият вариант е натискайки "CTRL+," и да търсите `include path` и от там да го добавите ръчно.

![](https://i.ibb.co/3cW4R7S/image.png)

<h3>д) Компилация</h3>

Тази стъпка е много относителна. Всяка библиотека се компилира по различен начин. Затова е най-добре да следвате стъпките описани от създателите.

Стъпките за SDL:

- При компилация ни трябват тези команди:

    `g++ -c main.cpp -I SDL_PATH/include` -> генерираме object файлът.

    `g++ main.o -o app.exe -L SDL_PATH/lib -l SDL2` -> линкваме object файлът с необходимите библиотеки.

    - След като сме компилирали exe файлът остава да му предоставим всички .dll файлове, които са необходими. За тази цел беше папката /bin, за която ставаше въпрос в стъпка в). Вътре в нея се намират тези библиотеки.